{"ast":null,"code":"import _defineProperty from \"/home/onabanji/M2 courses/GLI_Marc-Christie/TP/abiola_onabanji_reacte_m2_ccn/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { createStore, applyMiddleware } from 'redux';\nimport { createLogger } from 'redux-logger'; // This will log into our console information about redux actions & store\n\nimport thunk from 'redux-thunk'; // This middleware allows us to use Promises in our actions (async in action)\n\nimport rootReducer from './reducers/rootReducer'; // We will implement this later on, create a file exporting and empty object for now\n\nimport createRootReducer from './reducers/reducer';\nimport { fetchCosts, fetchUsers } from '../model/index';\nconst middlewares = applyMiddleware(thunk, createLogger());\nexport function injectAsyncActionHandler(store, name, asyncHandler) {\n  store.asyncReducers[name] = asyncHandler.reducer;\n  store.replaceReducer(createRootReducer(store.asyncReducers));\n  store.dispatch(asyncHandler.dispatcher);\n}\nexport default function configureStore(preloadedState = {}) {\n  // preloadedState is useful for SSR, which we don't use\n  const asyncHandlers = {\n    users: createAsyncActionHandler('FETCH_USERS', fetchUsers(), []),\n    costs: createAsyncActionHandler('FETCH_COSTS', fetchCosts(), [])\n  };\n  const store = createStore(createRootReducer(), preloadedState, middlewares);\n  store.asyncReducers = {};\n\n  store.update = () => {\n    for (const handler in asyncHandlers) {\n      store.dispatch(handler.dispatcher);\n    }\n  };\n\n  for (let key in asyncHandlers) {\n    injectAsyncActionHandler(store, key, asyncHandlers[key]);\n  }\n\n  return store;\n}\n/**\n * Create an asynchronous action handler, which means a couple composed of the promise\n * dispatcher and the associated reducer\n *  - dispatcher is responsible for starting the promise resolution and dispatching action corresponding\n *    to different request resolution state\n *  - reducer is the handler responsible for managing the state during the promise resolution lifecycle\n * (I tried to make more abstract the management of asynchronous action handling, it's a try and \n * it's probably not a good and used pattern in React)\n * @param {string} actionType The action prefix used during all the async treatment lifecycle\n * @param {Promise} promise The promise that will be used to retrieve data synchronously\n * @param {mixed} defaultValue Default value if promise fail or return null value\n */\n\nfunction createAsyncActionHandler(actionType, promise, defaultValue = {}) {\n  /**\n   * The async state wraps the value and trace the state of the promise resolution (pending, fetched, etc.)\n   */\n  function asyncState() {\n    return {\n      pending: false,\n      fetched: false,\n      error: null,\n      value: defaultValue\n    };\n  }\n  /**\n   * Execute the promise and dispatch actions according to its state.\n   * Given that reducer and dispatcher is generated in the same scope,\n   *   so it ensures that they manage the same actions.     * \n   * @param {*} dispatch \n   */\n\n\n  function dispatcher(dispatch) {\n    dispatch({\n      type: actionType + '.start'\n    });\n    promise.then(response => // Dispatch the action for fulfilled promise\n    dispatch({\n      type: actionType + '.fulfilled',\n      payload: response\n    })).catch(err => dispatch({\n      type: actionType + '.error',\n      payload: err\n    }));\n  }\n\n  function onStart(currentState) {\n    return _objectSpread({}, currentState, {\n      pending: true\n    });\n  }\n\n  function onError(currentState, payload) {\n    return _objectSpread({}, currentState, {\n      pending: false,\n      error: payload\n    });\n  }\n\n  function onFulfilled(currentState, payload) {\n    return _objectSpread({}, currentState, {\n      pending: false,\n      fetched: true,\n      value: payload\n    });\n  }\n\n  function reducer(state = asyncState(), action) {\n    // Only treat action with the matching prefix\n    if (action.type.substring(0, actionType.length) !== actionType) return state; // Parsing the promise phase from the action name (start, error, fulfilled)\n\n    const phase = action.type.substring(action.type.lastIndexOf(\".\") + 1);\n    const actionHandlers = {\n      'start': () => onStart(state),\n      'error': () => onError(state, action.payload),\n      'fulfilled': () => onFulfilled(state, action.payload)\n    }; // Executing the corresponding handler to create the state, or return the state by default\n\n    return (actionHandlers[phase] || (() => state))();\n  }\n\n  return {\n    reducer,\n    dispatcher\n  };\n}","map":{"version":3,"sources":["/home/onabanji/M2 courses/GLI_Marc-Christie/TP/abiola_onabanji_reacte_m2_ccn/src/redux/configureStore.js"],"names":["createStore","applyMiddleware","createLogger","thunk","rootReducer","createRootReducer","fetchCosts","fetchUsers","middlewares","injectAsyncActionHandler","store","name","asyncHandler","asyncReducers","reducer","replaceReducer","dispatch","dispatcher","configureStore","preloadedState","asyncHandlers","users","createAsyncActionHandler","costs","update","handler","key","actionType","promise","defaultValue","asyncState","pending","fetched","error","value","type","then","response","payload","catch","err","onStart","currentState","onError","onFulfilled","state","action","substring","length","phase","lastIndexOf","actionHandlers"],"mappings":"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","sourcesContent":["import { createStore, applyMiddleware } from 'redux'\nimport { createLogger } from 'redux-logger' // This will log into our console information about redux actions & store\nimport thunk from 'redux-thunk' // This middleware allows us to use Promises in our actions (async in action)\n\nimport rootReducer from './reducers/rootReducer' // We will implement this later on, create a file exporting and empty object for now\nimport createRootReducer from './reducers/reducer'\nimport { fetchCosts, fetchUsers } from '../model/index'\n\n\nconst middlewares = applyMiddleware(thunk, createLogger())\n\n\nexport function injectAsyncActionHandler(store, name, asyncHandler){\n  store.asyncReducers[name] = asyncHandler.reducer;\n  store.replaceReducer(createRootReducer(store.asyncReducers));\n  store.dispatch(asyncHandler.dispatcher)\n}\n\n\nexport default function configureStore(preloadedState = {}) { // preloadedState is useful for SSR, which we don't use\n  const asyncHandlers = {\n    users: createAsyncActionHandler('FETCH_USERS', fetchUsers(), []),\n    costs: createAsyncActionHandler('FETCH_COSTS', fetchCosts(), [])\n  }\n\n  const store = createStore(createRootReducer(), preloadedState, middlewares)\n  store.asyncReducers = {};\n\n  store.update = () => {\n    for (const handler in asyncHandlers) {\n      store.dispatch(handler.dispatcher)\n    }\n  }\n\n  for (let key in asyncHandlers) {\n    injectAsyncActionHandler(store, key, asyncHandlers[key])\n  }\n\n  return store\n}\n\n\n/**\n * Create an asynchronous action handler, which means a couple composed of the promise\n * dispatcher and the associated reducer\n *  - dispatcher is responsible for starting the promise resolution and dispatching action corresponding\n *    to different request resolution state\n *  - reducer is the handler responsible for managing the state during the promise resolution lifecycle\n * (I tried to make more abstract the management of asynchronous action handling, it's a try and \n * it's probably not a good and used pattern in React)\n * @param {string} actionType The action prefix used during all the async treatment lifecycle\n * @param {Promise} promise The promise that will be used to retrieve data synchronously\n * @param {mixed} defaultValue Default value if promise fail or return null value\n */\nfunction createAsyncActionHandler(actionType, promise, defaultValue = {}) {\n\n  /**\n   * The async state wraps the value and trace the state of the promise resolution (pending, fetched, etc.)\n   */\n  function asyncState() {\n      return {\n          pending: false,\n          fetched: false,\n          error: null,\n          value: defaultValue\n      }\n  }\n\n  /**\n   * Execute the promise and dispatch actions according to its state.\n   * Given that reducer and dispatcher is generated in the same scope,\n   *   so it ensures that they manage the same actions.     * \n   * @param {*} dispatch \n   */\n  function dispatcher(dispatch) {\n      dispatch({ type: actionType + '.start' })\n      promise\n          .then(response =>\n              // Dispatch the action for fulfilled promise\n              dispatch({ type: actionType + '.fulfilled', payload: response }))\n          .catch(err =>\n              dispatch({ type: actionType + '.error', payload: err }))\n  }\n\n  function onStart(currentState) {\n      return { ...currentState, pending: true }\n  }\n\n  function onError(currentState, payload) {\n      return { ...currentState, pending: false, error: payload }\n  }\n\n  function onFulfilled(currentState, payload) {\n      return {\n          ...currentState,\n          pending: false,\n          fetched: true,\n          value: payload\n      }\n  }\n\n  function reducer(state = asyncState(), action) {\n      // Only treat action with the matching prefix\n      if (action.type.substring(0, actionType.length) !== actionType)\n          return state\n\n      // Parsing the promise phase from the action name (start, error, fulfilled)\n      const phase = action.type.substring(action.type.lastIndexOf(\".\") + 1)\n\n      const actionHandlers = {\n          'start': () => onStart(state),\n          'error': () => onError(state, action.payload),\n          'fulfilled': () => onFulfilled(state, action.payload)\n      }\n\n      // Executing the corresponding handler to create the state, or return the state by default\n      return (actionHandlers[phase] || (() => state))()\n  }\n\n  return {\n      reducer,\n      dispatcher\n  }\n\n}\n\n"]},"metadata":{},"sourceType":"module"}