{"ast":null,"code":"import _defineProperty from\"/home/onabanji/M2 courses/GLI_Marc-Christie/TP/abiola_onabanji_reacte_m2_ccn/node_modules/@babel/runtime/helpers/esm/defineProperty\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(source,true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(source).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}import{createStore,applyMiddleware}from'redux';import{createLogger}from'redux-logger';// This will log into our console information about redux actions & store\nimport thunk from'redux-thunk';// This middleware allows us to use Promises in our actions (async in action)\n//import rootReducer from './reducers/rootReducer' // We will implement this later on, create a file exporting and empty object for now\nimport createRootReducer from'./reducers/reducer';import{fetchCosts,fetchUsers}from'../model/index';var middlewares=applyMiddleware(thunk,createLogger());export function injectAsyncActionHandler(store,name,asyncHandler){store.asyncReducers[name]=asyncHandler.reducer;store.replaceReducer(createRootReducer(store.asyncReducers));store.dispatch(asyncHandler.dispatcher);}export default function configureStore(){var preloadedState=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};// preloadedState is useful for SSR, which we don't use\nvar asyncHandlers={users:createAsyncActionHandler('FETCH_USERS',fetchUsers(),[]),costs:createAsyncActionHandler('FETCH_COSTS',fetchCosts(),[])};var store=createStore(createRootReducer(),preloadedState,middlewares);store.asyncReducers={};store.update=function(){for(var handler in asyncHandlers){store.dispatch(handler.dispatcher);}};for(var key in asyncHandlers){injectAsyncActionHandler(store,key,asyncHandlers[key]);}return store;}/**\n * Create an asynchronous action handler, which means a couple composed of the promise\n * dispatcher and the associated reducer\n *  - dispatcher is responsible for starting the promise resolution and dispatching action corresponding\n *    to different request resolution state\n *  - reducer is the handler responsible for managing the state during the promise resolution lifecycle\n * (I tried to make more abstract the management of asynchronous action handling, it's a try and \n * it's probably not a good and used pattern in React)\n * @param {string} actionType The action prefix used during all the async treatment lifecycle\n * @param {Promise} promise The promise that will be used to retrieve data synchronously\n * @param {mixed} defaultValue Default value if promise fail or return null value\n */function createAsyncActionHandler(actionType,promise){var defaultValue=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};/**\n   * The async state wraps the value and trace the state of the promise resolution (pending, fetched, etc.)\n   */function asyncState(){return{pending:false,fetched:false,error:null,value:defaultValue};}/**\n   * Execute the promise and dispatch actions according to its state.\n   * Given that reducer and dispatcher is generated in the same scope,\n   *   so it ensures that they manage the same actions.     * \n   * @param {*} dispatch \n   */function dispatcher(dispatch){dispatch({type:actionType+'.start'});promise.then(function(response){return(// Dispatch the action for fulfilled promise\ndispatch({type:actionType+'.fulfilled',payload:response}));}).catch(function(err){return dispatch({type:actionType+'.error',payload:err});});}function onStart(currentState){return _objectSpread({},currentState,{pending:true});}function onError(currentState,payload){return _objectSpread({},currentState,{pending:false,error:payload});}function onFulfilled(currentState,payload){return _objectSpread({},currentState,{pending:false,fetched:true,value:payload});}function reducer(){var state=arguments.length>0&&arguments[0]!==undefined?arguments[0]:asyncState();var action=arguments.length>1?arguments[1]:undefined;// Only treat action with the matching prefix\nif(action.type.substring(0,actionType.length)!==actionType)return state;// Parsing the promise phase from the action name (start, error, fulfilled)\nvar phase=action.type.substring(action.type.lastIndexOf(\".\")+1);var actionHandlers={'start':function start(){return onStart(state);},'error':function error(){return onError(state,action.payload);},'fulfilled':function fulfilled(){return onFulfilled(state,action.payload);}};// Executing the corresponding handler to create the state, or return the state by default\nreturn(actionHandlers[phase]||function(){return state;})();}return{reducer:reducer,dispatcher:dispatcher};}","map":{"version":3,"sources":["/home/onabanji/M2 courses/GLI_Marc-Christie/TP/abiola_onabanji_reacte_m2_ccn/src/redux/configureStore.js"],"names":["createStore","applyMiddleware","createLogger","thunk","createRootReducer","fetchCosts","fetchUsers","middlewares","injectAsyncActionHandler","store","name","asyncHandler","asyncReducers","reducer","replaceReducer","dispatch","dispatcher","configureStore","preloadedState","asyncHandlers","users","createAsyncActionHandler","costs","update","handler","key","actionType","promise","defaultValue","asyncState","pending","fetched","error","value","type","then","response","payload","catch","err","onStart","currentState","onError","onFulfilled","state","action","substring","length","phase","lastIndexOf","actionHandlers"],"mappings":"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","sourcesContent":["import { createStore, applyMiddleware } from 'redux'\nimport { createLogger } from 'redux-logger' // This will log into our console information about redux actions & store\nimport thunk from 'redux-thunk' // This middleware allows us to use Promises in our actions (async in action)\n\n//import rootReducer from './reducers/rootReducer' // We will implement this later on, create a file exporting and empty object for now\nimport createRootReducer from './reducers/reducer'\nimport { fetchCosts, fetchUsers } from '../model/index'\n\n\nconst middlewares = applyMiddleware(thunk, createLogger())\n\n\nexport function injectAsyncActionHandler(store, name, asyncHandler){\n  store.asyncReducers[name] = asyncHandler.reducer;\n  store.replaceReducer(createRootReducer(store.asyncReducers));\n  store.dispatch(asyncHandler.dispatcher)\n}\n\n\nexport default function configureStore(preloadedState = {}) { // preloadedState is useful for SSR, which we don't use\n  const asyncHandlers = {\n    users: createAsyncActionHandler('FETCH_USERS', fetchUsers(), []),\n    costs: createAsyncActionHandler('FETCH_COSTS', fetchCosts(), [])\n  }\n\n  const store = createStore(createRootReducer(), preloadedState, middlewares)\n  store.asyncReducers = {};\n\n  store.update = () => {\n    for (const handler in asyncHandlers) {\n      store.dispatch(handler.dispatcher)\n    }\n  }\n\n  for (let key in asyncHandlers) {\n    injectAsyncActionHandler(store, key, asyncHandlers[key])\n  }\n\n  return store\n}\n\n\n/**\n * Create an asynchronous action handler, which means a couple composed of the promise\n * dispatcher and the associated reducer\n *  - dispatcher is responsible for starting the promise resolution and dispatching action corresponding\n *    to different request resolution state\n *  - reducer is the handler responsible for managing the state during the promise resolution lifecycle\n * (I tried to make more abstract the management of asynchronous action handling, it's a try and \n * it's probably not a good and used pattern in React)\n * @param {string} actionType The action prefix used during all the async treatment lifecycle\n * @param {Promise} promise The promise that will be used to retrieve data synchronously\n * @param {mixed} defaultValue Default value if promise fail or return null value\n */\nfunction createAsyncActionHandler(actionType, promise, defaultValue = {}) {\n\n  /**\n   * The async state wraps the value and trace the state of the promise resolution (pending, fetched, etc.)\n   */\n  function asyncState() {\n      return {\n          pending: false,\n          fetched: false,\n          error: null,\n          value: defaultValue\n      }\n  }\n\n  /**\n   * Execute the promise and dispatch actions according to its state.\n   * Given that reducer and dispatcher is generated in the same scope,\n   *   so it ensures that they manage the same actions.     * \n   * @param {*} dispatch \n   */\n  function dispatcher(dispatch) {\n      dispatch({ type: actionType + '.start' })\n      promise\n          .then(response =>\n              // Dispatch the action for fulfilled promise\n              dispatch({ type: actionType + '.fulfilled', payload: response }))\n          .catch(err =>\n              dispatch({ type: actionType + '.error', payload: err }))\n  }\n\n  function onStart(currentState) {\n      return { ...currentState, pending: true }\n  }\n\n  function onError(currentState, payload) {\n      return { ...currentState, pending: false, error: payload }\n  }\n\n  function onFulfilled(currentState, payload) {\n      return {\n          ...currentState,\n          pending: false,\n          fetched: true,\n          value: payload\n      }\n  }\n\n  function reducer(state = asyncState(), action) {\n      // Only treat action with the matching prefix\n      if (action.type.substring(0, actionType.length) !== actionType)\n          return state\n\n      // Parsing the promise phase from the action name (start, error, fulfilled)\n      const phase = action.type.substring(action.type.lastIndexOf(\".\") + 1)\n\n      const actionHandlers = {\n          'start': () => onStart(state),\n          'error': () => onError(state, action.payload),\n          'fulfilled': () => onFulfilled(state, action.payload)\n      }\n\n      // Executing the corresponding handler to create the state, or return the state by default\n      return (actionHandlers[phase] || (() => state))()\n  }\n\n  return {\n      reducer,\n      dispatcher\n  }\n\n}\n\n"]},"metadata":{},"sourceType":"module"}